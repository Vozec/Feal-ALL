from FEAL.utils import *
from FEAL.feal_nx import *
from FEAL.feal_n import *

##############################################################################
### TEST FEAL NX #############################################################
##############################################################################
# Test from https://info.isl.ntt.co.jp/crypt/eng/archive/dl/feal/call-3e.pdf

# Function test  'f2'
assert [0x10,0x04,0x10,0x44] == F2([0x00,0xff,0xff,0x00],[0xff,0xff])

# Function test 'fk'
assert [0x10,0x04,0x10,0x44] == Fk([0x00,0x00,0x00,0x00],[0x00,0x00,0x00,0x00])

# Function test 'S1'
assert S1(0b10011,0b11110010) == 0b00011000

# Function test 'key_generation'
K = bytes([0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0XEF,
		   0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0XEF])

assert Feal_NX(key = K,rounds = 32).subkey == [
	0x75,0x19,0x71,0xf9,0x84,0xe9,0x48,0x86,
	0x88,0xe5,0x52,0x3b,0x4e,0xa4,0x7a,0xde,
	0xfe,0x40,0x5e,0x76,0x98,0x19,0xee,0xac,
	0x1b,0xd4,0x24,0x55,0xdc,0xa0,0x65,0x3b,
	0x3e,0x32,0x46,0x52,0x1c,0xc1,0x34,0xdf,
	0x77,0x8b,0x77,0x1d,0xd3,0x24,0x84,0x10,
	0x1c,0xa8,0xbc,0x64,0xa0,0xdb,0xbd,0xd2,
	0x1f,0x5f,0x8f,0x1c,0x6b,0x81,0xb5,0x60,
	0x19,0x6a,0x9a,0xb1,0xe0,0x15,0x81,0x90,
	0x9f,0x72,0x66,0x43,0xad,0x32,0x68,0x3a
]

# Function test 'encrypt'
P = bytes([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
assert Feal_NX(key = K,rounds = 32).encrypt(P) == bytes([0x9c,0x9b,0x54,0x97,0x3d,0xf6,0x85,0xf8])

# Function test 'decrypt'
C = bytes([0x9c,0x9b,0x54,0x97,0x3d,0xf6,0x85,0xf8])
assert Feal_NX(key = K,rounds = 32).decrypt(C) == bytes([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00]).strip(b'\x00')

# Test from https://link.springer.com/content/pdf/10.1007/3-540-38424-3_46.pdf
# Function test 'encrypt' NÂ°2
K = [0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
	 0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF]

P = bytes([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
test = {
	4:bytes([0xDF,0x7B,0xED,0xD3,0xD5,0x9C,0x7C,0x4B]),
	8:bytes([0x92,0xBE,0xB6,0x5D,0x0E,0x93,0x82,0xFB]),
	16:bytes([0x01,0xA9,0x43,0x83,0xEB,0x19,0xBA,0x07]),
	32:bytes([0x9C,0x9B,0x54,0x97,0x3D,0xF6,0x85,0xF8]),
	64:bytes([0xE2,0xB0,0xF1,0xC2,0x98,0xEB,0x50,0x30]),
}
for N,ct in test.items():
	assert Feal_NX(key = K,rounds = N).encrypt(P) == ct

##############################################################################
##############################################################################
##############################################################################

##############################################################################
### TEST FEAL N ##############################################################
##############################################################################
# Test from https://link.springer.com/content/pdf/10.1007/3-540-38424-3_46.pdf

# Function test 'key_generation'
K = [0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF]
assert Feal_N(key = K,rounds = 8).subkey == [
	0xDF,0x3B,0xCA,0x36,0xF1,0x7C,0x1A,0xEC,
	0x45,0xA5,0xB9,0xC7,0x26,0xEB,0xAD,0x25,
	0x8B,0x2A,0xEC,0xB7,0xAC,0x50,0x9D,0x4C,
	0x22,0xCD,0x47,0x9B,0xA8,0xD5,0x0C,0xB5
]

# Function test 'encrypt'
P = bytes([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
assert Feal_N(key = K,rounds = 8).encrypt(P) == bytes([0xCE,0xEF,0x2C,0x86,0xF2,0x49,0x07,0x52])

# Function test 'decrypt'
C = bytes([0xCE,0xEF,0x2C,0x86,0xF2,0x49,0x07,0x52]) 
assert Feal_N(key = K,rounds = 8).decrypt(C) == bytes([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])


##############################################################################
##############################################################################
##############################################################################
